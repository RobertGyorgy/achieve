---
// HeroSection.astro - Refined Version
---

<section
  class="relative h-[100svh] w-full bg-[#F2F2F2] overflow-hidden"
  id="hero-section"
  data-theme-color="#F2F2F2"
  style="z-index: 1;"
>
  <div
    id="hero-content-wrapper"
    class="absolute inset-0 flex flex-col justify-between box-border gap-12 md:gap-32 lg:gap-0"
    style="transform-origin: center center;"
  >
    <!-- Dot Grid Background Canvas -->
    <canvas id="dot-grid-canvas" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>

    <div
      class="hero-section-container w-full h-full flex flex-col justify-between box-border gap-12 md:gap-32 lg:gap-0 relative"
    >
      <!-- Top: ACHIEVE -->
      <div class="hero-top hidden md:block mb-12 md:mb-32 lg:mb-0">
        <h1 class="achieve-hero-title flex justify-between w-full">
          <span class="hero-text-word" data-tooltip="Drag">A</span>
          <span class="hero-text-word" data-tooltip="Drag">C</span>
          <span class="hero-text-word" data-tooltip="Drag">H</span>
          <span class="hero-text-word" data-tooltip="Drag">I</span>
          <span class="hero-text-word" data-tooltip="Drag">E</span>
          <span class="hero-text-word" data-tooltip="Drag">V</span>
          <span class="hero-text-word" data-tooltip="Drag">E</span>
        </h1>
      </div>

      <!-- Middle: Headline -->
      <div
        class="hero-middle flex-1 md:flex-none flex flex-col justify-center items-center md:items-start pl-0 md:pl-2 md:mb-32 lg:mb-0 w-full"
      >
        <!-- Mobile Layout: 3 Stacked Rows (Visible only on mobile) -->
        <div class="md:hidden w-full flex flex-col items-center justify-center">
          <div class="hero-title-row flex justify-center w-full">
            <span
              class="hero-text-word headline-word mobile-max text-[#222831]"
              data-tooltip="Drag">CREĂM</span
            >
          </div>
          <div class="hero-title-row flex justify-center w-full">
            <span
              class="hero-text-word headline-word mobile-max text-[#222831]"
              data-tooltip="Drag">IMPACT</span
            >
          </div>
          <div class="hero-title-row flex justify-center w-full">
            <span
              class="hero-text-word headline-word mobile-max accent text-[#ff4500]"
              data-tooltip="Drag">DIGITAL</span
            >
          </div>
        </div>

        <!-- Desktop Layout: 1 Single Row (Visible only on desktop) -->
        <div
          class="hidden md:flex hero-title-row justify-start gap-x-[1vw] w-full"
        >
          <span
            class="hero-text-word headline-word desktop-min text-[#222831]"
            data-tooltip="Drag">CREĂM</span
          >
          <span
            class="hero-text-word headline-word desktop-min text-[#222831]"
            data-tooltip="Drag">IMPACT</span
          >
          <span
            class="hero-text-word headline-word desktop-min accent text-[#ff4500]"
            data-tooltip="Drag">DIGITAL</span
          >
        </div>
      </div>

      <!-- Bottom Row -->
      <div
        class="hero-bottom w-full flex flex-col md:flex-row items-center md:items-end justify-between gap-12 md:gap-32 lg:gap-0"
      >
        <!-- Functional Buttons (Literal 1:1 Copy from HeroSection.astro) -->
        <div class="hero-buttons-overlay">
          <button class="cutout-button primary blob-btn" id="lets-talk-btn"
            >Let's Talk</button
          >
          <button class="cutout-button secondary blob-btn" id="process-btn"
            >Our Process</button
          >
        </div>

        <!-- Studio Label -->
        <div class="text-right hidden md:block">
          <p
            class="font-nura font-bold text-[#222831] text-xs md:text-xl uppercase leading-tight tracking-wide"
          >
            PREMIUM<br />
            WEB DEVELOPMENT<br />
            & DESIGN STUDIO
          </p>
        </div>
      </div>
    </div>

    <!-- Drag Tooltip (Mobile only) -->
    <div id="drag-tooltip" class="drag-tooltip">Drag me</div>
  </div><!-- End hero-content-wrapper -->
</section>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  import { initBubbleButtons } from '../scripts/bubble-button';
  import { isMobile } from '../scripts/smooth-scroll';
  import { initDotGrid } from '../scripts/dot-grid';

  gsap.registerPlugin(ScrollTrigger);

  // Helper to prepare elements for Character-by-Character or Word Reveal
  function wrapForAppearance(element: HTMLElement, splitByCharacters = false) {
    if (element.children.length > 0 && !splitByCharacters) {
      // If it has children (like the mobile 3 rows of spans) and we're not splitting by char,
      // iterate and wrap the text of each child span, preserving the DOM structure.
      Array.from(element.children).forEach((child) => {
        const text = (child as HTMLElement).innerText;
        child.innerHTML = `<span class="char-inner" style="display: inline-block; will-change: transform, opacity;">${text}</span>`;
      });
    } else {
      const text = element.innerText;

      if (splitByCharacters) {
        // Split into single characters
        element.innerHTML = text
          .split('')
          .map((char) => {
            if (char === ' ') return ' ';
            return `<span class="char-inner" style="display: inline-block; will-change: transform, opacity;">${char}</span>`;
          })
          .join('');
      } else {
        // Split into word inner (for headline words)
        element.innerHTML = `<span class="char-inner" style="display: inline-block; will-change: transform, opacity;">${text}</span>`;
      }
    }

    // Ensure parent has perspective for 3D state
    const parentRow = element.parentElement;
    if (parentRow) {
      parentRow.style.overflow = 'hidden';
      parentRow.style.perspective = '1000px';
    }
    element.style.display = 'inline-block';
    element.style.overflow = 'visible';
    element.style.verticalAlign = 'top';
  }

  function initHeroContent() {
    const preloader = document.getElementById('preloader');
    const preloaderLetters = document.querySelectorAll('.preloader-letter');

    // If preloader exists (initial load), wait for it to finish
    if (preloader && preloaderLetters.length) {
      initPreloader(preloader, preloaderLetters);
    } else {
      // If no preloader (client-side navigation), reveal immediately
      revealHeroContent();
    }

    initDraggable();
    initTooltip();
    initDotGridCanvas();
  }

  let dotGridCleanup: (() => void) | null = null;

  function initDotGridCanvas() {
    // Clean up previous instance (Astro page transitions)
    if (dotGridCleanup) {
      dotGridCleanup();
      dotGridCleanup = null;
    }

    // Skip dot grid on mobile — only show on desktop
    if (window.innerWidth < 1024) return;

    const canvas = document.getElementById('dot-grid-canvas') as HTMLCanvasElement;
    const wrapper = document.getElementById('hero-content-wrapper');
    if (!canvas || !wrapper) return;

    dotGridCleanup = initDotGrid(canvas, wrapper, {
      dotSize: 5,
      gap: 50,
      baseColor: '#C8BEB4',
      activeColor: '#ff4500',
      proximity: 120,
      shockRadius: 250,
      shockStrength: 5,
      resistance: 750,
      returnDuration: 1.5,
    });
  }

  // Lifecycle
  document.addEventListener('astro:page-load', () => {
    // Other cleanups if needed
  });

  function initPreloader(preloader: HTMLElement, letters: NodeList) {
    const tl = gsap.timeline();

    // PHASE 1: Animate preloader letters in
    tl.to(letters, {
      opacity: 1,
      y: 0,
      rotateX: 0,
      duration: 0.6,
      stagger: 0.08,
      ease: 'back.out(1.7)',
    });

    // PHASE 2: Hold & Fade Out
    tl.to({}, { duration: 0.5 });
    tl.to(letters, {
      opacity: 0,
      y: -30,
      rotateX: 90,
      duration: 0.5,
      stagger: 0.04,
      ease: 'back.in(1.7)',
    });

    // PHASE 3: Hide Preloader & Reveal Hero
    tl.set(preloader, {
      display: 'none',
      zIndex: -1,
      onComplete: () => {
        revealHeroContent();
      },
    });
  }

  function revealHeroContent() {
    // Notify navbar to reveal itself
    document.dispatchEvent(new CustomEvent('reveal-navbar'));

    const heroWords = document.querySelectorAll('.hero-text-word');
    const buttonsOverlay = document.querySelector('.hero-buttons-overlay');
    const buttons = document.querySelectorAll('.hero-buttons-overlay button');

    if (!heroWords.length) return;

    // Split ACHIEVE letters specifically
    const achieveHeroTitle = document.querySelector('.achieve-hero-title');
    if (achieveHeroTitle) {
      achieveHeroTitle.querySelectorAll('.hero-text-word').forEach((el) => {
        wrapForAppearance(el as HTMLElement, true);
      });
    }

    // Wrap headline words as single units
    document.querySelectorAll('.headline-word').forEach((el) => {
      wrapForAppearance(el as HTMLElement, false);
    });

    const chars = document.querySelectorAll('.char-inner');

    const tl = gsap.timeline();

    // Premium Staggered Character Reveal
    tl.fromTo(
      chars,
      {
        y: 40,
        rotateX: -90,
        opacity: 0,
        transformOrigin: '50% 0%',
      },
      {
        y: 0,
        rotateX: 0,
        opacity: 1,
        duration: 1,
        stagger: 0.04,
        ease: 'back.out(1.7)',
        onComplete: () => {
          document
            .querySelectorAll('.hero-title-row, .achieve-hero-title')
            .forEach((row) => {
              (row as HTMLElement).style.overflow = 'visible';
            });
          heroWords.forEach((word) => {
            (word as HTMLElement).style.overflow = 'visible';
          });
        },
      }
    );

    // Button Reveal Logic
    if (buttonsOverlay && buttons.length) {
      gsap.set(buttonsOverlay, {
        visibility: 'visible',
        pointerEvents: 'auto',
      });
      tl.fromTo(
        buttons,
        {
          y: 50,
          scale: 0.8,
          opacity: 0,
        },
        {
          y: 0,
          scale: 1,
          opacity: 1,
          duration: 1,
          stagger: 0.2,
          ease: 'back.out(2)',
        },
        '-=1'
      );
    }

    setTimeout(() => {
      initBubbleButtons('.blob-btn');
    }, 100);
  }

  function initDraggable() {
    const heroWords = document.querySelectorAll('.hero-text-word');
    let zIndexCounter = 1000;
    let activeDragElement: HTMLElement | null = null;
    let activeDragState: any = null;
    let rafId: number = 0;

    const stopDragging = (element: HTMLElement) => {
      element.classList.remove('dragging');
      activeDragElement = null;
      activeDragState = null;
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      cancelAnimationFrame(rafId);
    };

    const returnToFlatAnimation = () => {
      if (!activeDragElement || !activeDragState) return;

      const currentRot = activeDragState.currentRotation || 0;
      
      gsap.to(activeDragState, {
        currentRotation: 0,
        duration: 0.5,
        ease: 'cubic.out',
        onUpdate: () => {
          const translateX = activeDragState.translateX || 0;
          const translateY = activeDragState.translateY || 0;
          const rotation = activeDragState.currentRotation || 0;
          
          activeDragElement!.style.transform = 
            `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg) translateZ(0)`;
        },
        onComplete: () => {
          activeDragState.currentRotation = 0;
        }
      });
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!activeDragElement || !activeDragState) return;

      const x = e.clientX - activeDragState.startX;
      const y = e.clientY - activeDragState.startY;

      activeDragState.translateX = x;
      activeDragState.translateY = y;

      // Calculate velocity
      const dx = e.clientX - activeDragState.lastX;
      const dy = e.clientY - activeDragState.lastY;

      activeDragState.lastX = e.clientX;
      activeDragState.lastY = e.clientY;

      // Get element rect for grab point calculation
      const rect = activeDragElement.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // Grab point relative to center
      const grabOffsetX = e.clientX - centerX;
      const grabOffsetY = e.clientY - centerY;

      // Calculate torque from cross product: (grabOffset × velocity)
      // In 2D: torque = grabOffsetX * velocityY - grabOffsetY * velocityX
      const torque = grabOffsetX * dy - grabOffsetY * dx;

      // Convert torque to angular velocity (small scale for subtle effect)
      activeDragState.rotationVelocity = torque * 0.004;

      // Accumulate rotation during drag
      activeDragState.currentRotation += activeDragState.rotationVelocity;
      
      // Clamp rotation to prevent extreme angles
      activeDragState.currentRotation = Math.max(-15, Math.min(15, activeDragState.currentRotation));

      const rotation = activeDragState.currentRotation || 0;
      activeDragElement.style.transform = 
        `translate(${x}px, ${y}px) rotate(${rotation}deg) translateZ(0)`;
    };

    const handleMouseUp = (e: MouseEvent) => {
      if (activeDragElement) {
        // Animate rotation back to flat (0 degrees)
        returnToFlatAnimation();
        
        // Clean up drag state after animation
        setTimeout(() => {
          stopDragging(activeDragElement!);
        }, 500);
      }
    };

    heroWords.forEach((el: any) => {
      el.addEventListener('mousedown', (e: MouseEvent) => {
        e.preventDefault();
        const transform = el.style.transform || '';
        const match = transform.match(
          /translate\(([-\d.]+)px,\s*([-\d.]+)px\)/
        );
        const curX = match ? parseFloat(match[1]) : 0;
        const curY = match ? parseFloat(match[2]) : 0;

        el.style.zIndex = (zIndexCounter++).toString();
        activeDragElement = el;
        activeDragState = {
          startX: e.clientX - curX,
          startY: e.clientY - curY,
          lastX: e.clientX,
          lastY: e.clientY,
          translateX: curX,
          translateY: curY,
          currentRotation: 0,
          rotationVelocity: 0,
        };
        el.classList.add('dragging');
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      });
    });
  }

  function initTooltip() {
    // Desktop only
    if (window.innerWidth < 1024) return;

    const tooltip = document.getElementById('drag-tooltip');
    if (!tooltip) return;

    const heroWords = document.querySelectorAll('.hero-text-word');

    // Spring physics state
    let targetX = 0;
    let targetY = 0;
    let currentX = 0;
    let currentY = 0;
    let velocityX = 0;
    let velocityY = 0;
    const friction = 0.85; // Dampening (lower = more damped, fewer bounces)
    const tension = 0.08; // Spring strength (lower = less overshoot)
    let rafId: number;

    const clampPos = (x: number, y: number) => {
      const rect = tooltip.getBoundingClientRect();
      const tooltipWidth = rect.width || 120;
      const tooltipHeight = rect.height || 40;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      const clampedX =
        x + tooltipWidth + 10 > viewportWidth
          ? viewportWidth - tooltipWidth - 10
          : x;
      const clampedY =
        y + tooltipHeight + 10 > viewportHeight
          ? viewportHeight - tooltipHeight - 10
          : y;

      return { x: clampedX, y: clampedY };
    };

    const updateTooltip = () => {
      if (!tooltip.classList.contains('visible')) {
        rafId = requestAnimationFrame(updateTooltip);
        return;
      }

      // Spring physics: move toward target with elasticity
      const dx = targetX - currentX;
      const dy = targetY - currentY;

      velocityX += dx * tension;
      velocityY += dy * tension;

      velocityX *= friction;
      velocityY *= friction;

      currentX += velocityX;
      currentY += velocityY;

      // Apply clamping
      const clamped = clampPos(currentX, currentY);
      currentX = clamped.x;
      currentY = clamped.y;

      tooltip.style.left = currentX + 'px';
      tooltip.style.top = currentY + 'px';

      rafId = requestAnimationFrame(updateTooltip);
    };

    // Start the animation loop
    rafId = requestAnimationFrame(updateTooltip);

    // Update target on mousemove
    document.addEventListener('mousemove', (e: MouseEvent) => {
      targetX = e.clientX + 10;
      targetY = e.clientY + 10;
    });

    heroWords.forEach((word: any) => {
      word.addEventListener('mouseenter', (e: MouseEvent) => {
        if (!word.classList.contains('dragging')) {
          tooltip.classList.add('visible');
          targetX = (e as MouseEvent).clientX + 10;
          targetY = (e as MouseEvent).clientY + 10;
          currentX = targetX;
          currentY = targetY;
        }
      });
      word.addEventListener('mouseleave', () =>
        tooltip.classList.remove('visible')
      );
    });
  }

  // Handle initialization on page load and Astro transitions
  document.addEventListener('DOMContentLoaded', initHeroContent);
  document.addEventListener('astro:page-load', initHeroContent);
</script>

<style is:global>
  .font-nura {
    font-family: 'Nura', serif !important;
  }

  .hero-section-container {
    padding: calc(12vh + env(safe-area-inset-top)) 5vw
      calc(6vh + env(safe-area-inset-bottom)) !important;
    min-height: 100vh; /* Fallback */
    min-height: 100svh; /* Small viewport height — fits screen with address bar visible */
    /* will-change removed to avoid stacking context issues with pinning */
  }

  @media (min-width: 768px) {
    .hero-section-container {
      padding: 18vh 5vw 6vh !important;
      min-height: auto;
    }
  }

  .hero-text-word {
    font-family: 'Nura', serif !important;
    font-weight: 900 !important;
    cursor: grab;
    user-select: none;
    display: inline-block;
    will-change: transform;
    transform-origin: center;
  }

  .hero-text-word.dragging {
    z-index: 10000 !important;
    cursor: grabbing;
  }

  .achieve-hero-title {
    font-size: 19vw; /* Maximized for mobile */
    line-height: 0.8;
    letter-spacing: -0.05em;
    color: #ff4500;
  }

  @media (min-width: 768px) {
    .achieve-hero-title {
      font-size: 18.5vw;
    }
  }

  .headline-word {
    font-size: 15vw;
    line-height: 0.85;
    text-transform: uppercase;
  }

  /* Mobile Maximized Size */
  .headline-word.mobile-max {
    font-size: 21vw;
    line-height: 0.85;
    letter-spacing: -0.04em;
  }

  /* Desktop Smaller Size */
  .headline-word.desktop-min {
    font-size: 5vw;
    line-height: normal;
    letter-spacing: normal;
  }

  @media (min-width: 768px) {
    .headline-word {
      font-size: 5vw; /* Default fallback */
    }
  }

  .hero-buttons-overlay {
    position: relative;
    display: flex;
    gap: calc(36 / 1920 * 100vw);
    z-index: 20;
    visibility: hidden;
    pointer-events: none;
    justify-content: center; /* Center on mobile */
    width: 100%; /* Full width for centering */
  }

  @media (min-width: 768px) {
    .hero-buttons-overlay {
      justify-content: flex-start;
      width: auto;
    }
  }

  .hero-buttons-overlay .cutout-button {
    opacity: 0;
  }

  .cutout-button {
    position: relative;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    padding: 1rem 2rem; /* Larger touch targets on mobile */
    font-size: 1.1rem; /* Larger text on mobile */
    white-space: nowrap; /* Keep on one line */
    border-radius: 9999px;
    font-family: 'Nura', sans-serif;
    font-weight: 600;
    cursor: pointer;
    pointer-events: auto;
    isolation: isolate;
    transition:
      transform 0.2s ease,
      border-color 0.3s ease,
      color 0.3s ease;
  }

  @media (min-width: 1024px) {
    .cutout-button {
      padding: calc(20 / 1920 * 100vw) calc(42 / 1920 * 100vw);
      font-size: calc(24 / 1920 * 100vw);
    }
  }

  .cutout-button.primary {
    background: #000000;
    color: #f2f2f2;
    border: none;
  }

  .cutout-button.primary:hover {
    color: #f2f2f2 !important;
  }

  .cutout-button.secondary {
    background: transparent;
    border: 2px solid #000000;
    color: #222831;
    transform: translateZ(0);
    -webkit-transform: translateZ(0);
  }

  .cutout-button.secondary:hover {
    border-color: #ff4500;
    color: #f2f2f2 !important;
  }

  .blob-btn {
    overflow: hidden;
    z-index: 1;
  }

  .blob-btn .work-blob {
    position: absolute;
    top: 0;
    left: 0;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #ff4500;
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.5s ease;
    z-index: -1;
    pointer-events: none;
  }

  .blob-btn .work-expand {
    transform: translate(-50%, -50%) scale(40);
  }

  .blob-btn:hover {
    color: #f2f2f2 !important;
  }

  @media (min-width: 1024px) {
    .drag-tooltip {
      position: fixed;
      pointer-events: none;
      z-index: 100000;
      opacity: 0;
      transform: translate(10px, 10px);
      transition:
        opacity 0.2s ease,
        transform 0.2s ease;
      background: #000000;
      color: #f2f2f2;
      padding: 12px 24px;
      border-radius: 9999px;
      font-size: 16px;
      font-weight: 600;
      font-family: 'Nura', serif;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      margin-left: -10px;
      margin-top: 10px;
    }

    .drag-tooltip.visible {
      opacity: 1;
      transform: translate(10px, 10px);
    }
  }

</style>
